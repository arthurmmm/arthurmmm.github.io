<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>ArthurMao's Blog</title>
		<description>你好喵 ・ω・~☆</description>
		<link>http://www.arthurmao.me</link>
		<atom:link href="http://www.arthurmao.me/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>Django框架下表单的开发模型</title>
				<description>&lt;p&gt;介绍使用Django Form + Bootstrap实现表单管理的思路和方式&lt;/p&gt;

&lt;h2 id=&quot;djangomodelform&quot;&gt;创建Django的ModelForm模块&lt;/h2&gt;

&lt;p&gt;Django的Form类可以在后台生成和管理表单，而其中的ModelForm类更是可以方便的将数据库模型映射成一个表单，实现快速开发。 &lt;br /&gt;
文档：https://docs.djangoproject.com/en/1.9/topics/forms/modelforms/   &lt;/p&gt;

&lt;p&gt;简单来讲流程如下   &lt;/p&gt;

&lt;p&gt;```python
## 1. Define a ModelForm class
class MyForm(ModelForm):
    ## 2. Add a subclass “Meta”
    class Meta:
        model = MyModel ## 3. Define the Model you use
        fields = ‘&lt;strong&gt;all&lt;/strong&gt;’ ## 4. The fields you want to show&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h3 id=&quot;djangobootstrap&quot;&gt;让Django生成Bootstrap风格的表单&lt;/h3&gt;

&lt;p&gt;Django自动生成的表单并不能很好的契合前端Bootstrap的风格，因为Bootstrap的表单需要将每个域囊括在’form-control’的DIV中。 &lt;br /&gt;
解决方法如下：   &lt;/p&gt;

&lt;p&gt;&lt;code&gt;python
class MyForm(ModelForm):
    def __init__(self, *args, **kwargs):
        super(MyForm, self).__init__(*args, **kwargs)
        for field in iter(self.field):
            self.fields[field].widget.attrs.update({
                &#39;class&#39;: &#39;form-control&#39;,
            })
&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;widget&quot;&gt;重定义/初始化表单Widget&lt;/h3&gt;

&lt;p&gt;默认情况下Django会根据Model的属性自动生成Widget，不过有时候我们也会需要自定义部分Widget，比如添加提示或者设置成只读。 &lt;br /&gt;
我们可以在Meta中定义labels/widgets来实现这个功能：   &lt;/p&gt;

&lt;p&gt;```python
class MyForm(ModelForm):
    def &lt;strong&gt;init&lt;/strong&gt;(self, &lt;em&gt;args, **kwargs):
        super(MyForm, self).&lt;strong&gt;init&lt;/strong&gt;(&lt;/em&gt;args, **kwargs)
        for field in iter(self.field):
            self.fields[field].widget.attrs.update({
                ‘class’: ‘form-control’,
            })&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Meta:
    model = MyModel
    fields = &#39;__all__&#39;
    labels = {
        &#39;user_id&#39;: _(&#39;User&#39;), ## Rename user_id to User
    }
    widgets = {
        &#39;user_id&#39;: TextInput(attrs={&#39;readonly&#39;: True}), ## Set user_id as readonly
    } ```
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;section&quot;&gt;表单检查&lt;/h3&gt;

&lt;p&gt;Django的ModelForm默认会根据Model本身的限制进行检查（例如主键唯一，类型检查等） &lt;br /&gt;
我们也可以提供一些自定义检查规则：   &lt;/p&gt;

&lt;p&gt;```python
class MyForm(ModelForm):
    def &lt;strong&gt;init&lt;/strong&gt;(self, &lt;em&gt;args, **kwargs):
        super(MyForm, self).&lt;strong&gt;init&lt;/strong&gt;(&lt;/em&gt;args, **kwargs)
        for field in iter(self.field):
            self.fields[field].widget.attrs.update({
                ‘class’: ‘form-control’,
            })&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ## Use Bootstrap alert to show error message
    self.error_css_class = &#39;alert alert-danger&#39;
    self.required_css_class = &#39;alert alert-danger&#39;

def clean_name(self):
    v = self.cleaned_data[&#39;name&#39;]
    RegexValidattor(
        regex = &#39;^[a-z0-9_]+$&#39;, ## Only allow lower case chars, ints and underline
        message = _(&#39;Only allow lower case chars, ints and underline&#39;),
    )(v)
    return v
    
class Meta:
    model = MyModel
    fields = &#39;__all__&#39;
    labels = {
        &#39;user_id&#39;: _(&#39;User&#39;), ## Rename user_id to User
    }
    widgets = {
        &#39;user_id&#39;: TextInput(attrs={&#39;readonly&#39;: True}),
    } ```
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;template&quot;&gt;创建前端Template&lt;/h2&gt;

&lt;p&gt;后台类编写完毕后开始为前端页面创建模板，这里使用了Bootstrap的’form-horizontal’模板&lt;/p&gt;

&lt;p&gt;```html
&amp;lt;form class=&quot;form-horizontal&quot;&amp;gt;
    &lt;!-- Load general error --&gt;
    { % if form.errors % }
        { % for error in form.non_field_errors % }
            &amp;lt;div class=&quot;alert alert-danger&quot;&amp;gt; { { error|escape } }&amp;lt;/div&amp;gt;
        { % endfor % }
    { % endif % }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ % for field in form % }
    { % if field.errors % }
        &amp;lt;!-- Load fields error --&amp;gt;
        &amp;lt;div class=&quot;form-group has-error&quot;&amp;gt;
            &amp;lt;label class=&quot;col-xs-3 control-label&quot; for=&quot;{ { field.name } }&quot;&amp;gt;{ { field.label } }&amp;lt;/label&amp;gt;
            &amp;lt;div class=&quot;col-xs-9&quot;&amp;gt;{ { field } }&amp;lt;/div&amp;gt;
            &amp;lt;span class=&quot;help-block col-xs-12&quot;&amp;gt;{ { field.errors.as_text } }&amp;lt;/span&amp;gt;
        &amp;lt;/div&amp;gt;
    { % else % }
        &amp;lt;!-- Load fields only --&amp;gt;
        &amp;lt;div class=&quot;form-group&quot;&amp;gt;
            &amp;lt;label class=&quot;col-xs-3 control-label&quot; for=&quot;{ { field.name } }&quot;&amp;gt;{ { field.label } }&amp;lt;/label&amp;gt;
            &amp;lt;div class=&quot;col-xs-9&quot;&amp;gt;{ { field } }&amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    { % endif % }
{ % endfor % }
&amp;lt;div class=&quot;form-group&quot;&amp;gt;
    &amp;lt;div class=&quot;col-xs-offset-9 col-xs-3&quot;&amp;gt;
        &amp;lt;input type=&quot;submit&quot; class=&quot;btn btn-primary col-xs-12&quot; value=&quot;Submit&quot;&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;/form&amp;gt;
```&lt;/p&gt;

&lt;h2 id=&quot;views&quot;&gt;为表单创建views&lt;/h2&gt;

&lt;p&gt;有了ModelForm类和HTML模板，下面的步骤就是创建一个接口view用于将数据加载至模板中。 &lt;br /&gt;
在这里我们可以创建一个通用view class用于加载所有的ModelForm   &lt;/p&gt;

&lt;p&gt;```python
class FormView(View):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;## Exclude csrf check for POST
@method_decorator(csrf_exempt)
def dispatch(self, request, *args, **kwargs):
    return super(FormView, self).dispatch(request, *args, **kwargs)

## Get a form for new object, or get a form to edit existing object
## Using &#39;is_new&#39; param to identify if we want a new form.
def get(self, request, form_class, template):
    template_file  = &#39;myapp/form/%s.html&#39; % template ## a template file for form
    request_dict = request.GET.dict()
    is_new = request_dict.pop(&#39;is_new&#39;)
    if is_new == &#39;true&#39;:
        ## Generating a new form
        form = eval(form_class)(initial=request.GET.dict())
        id = &#39;&#39;
    else:
        ## Getting a model object, then load it to form for editing
        model = eval(form_class)._meta.model
        inst = model.object.get(**request_dict)
        form = eval(form_class)(instance=inst)
        id = inst.id
    context = {
        &#39;form&#39;: form,
        &#39;id&#39;: id,
        &#39;form_class&#39;: form_class,
        &#39;template&#39;: template,
    }
    return render(request, template_file, context)

## Edit existing form, steps:
## Get info submitted by form =&amp;gt; get model by info =&amp;gt; load model into form =&amp;gt; save form
def put(self, request, form_class, template):
    template_file = &#39;myapp/form/%s.html&#39; % template
    request_querydict = QueryDict(request.body, mutable=True)
    id = request_querydict.pop(&#39;id&#39;)[0]
    model = eval(form_class)._meta.model
    inst = model.objects.get(id=id)
    form = eval(form_class)(request_querydict, instance=inst)
    if form.is_valid():
        form.save()
        return HttpResponse(status=200)
    else:
        context = {
            &#39;form&#39;: form,
            &#39;id&#39;: id,
            &#39;form_class&#39;: form_class,
            &#39;template&#39;: template,
        }
        return render(request, template_file, context, status=400)

## Create a new model instance by submitted form 
def post(self, request, form_class, template):
    template_file = &#39;myapp/form/%s.html&#39; % template
    form = eval(form_class)(request.POST)
    if form.is_valid():
        form.save()
        return HttpResponse(status=200)
    else:
        context = {
            &#39;form&#39;: form,
            &#39;id&#39;: &#39;&#39;,
            &#39;form_class&#39;: form_class,
            &#39;template&#39;: template,
        }
        return render(request, template_file, context, status=400) ```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置urls.py：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;python
urlpatterns = [
    url(r&#39;_form/(?P&amp;lt;form_class&amp;gt;.+)/(?P&amp;lt;template&amp;gt;.+)/$&#39;),
]
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;有了这个view我们的思路就很清楚了： &lt;br /&gt;
1. 创建一个model：使用GET获取一个空表单(is_new=’true’) =&amp;gt; 使用POST提交表单
2. 编辑一个model：使用GET获取一个加载了现有数据的表单(is_new=’false’) =&amp;gt; 使用PUT提交表单&lt;/p&gt;

</description>
				<pubDate>Sun, 08 May 2016 16:27:00 +0800</pubDate>
				<link>http://www.arthurmao.me/2016/05/django-ajax-form-model</link>
				<guid isPermaLink="true">http://www.arthurmao.me/2016/05/django-ajax-form-model</guid>
			</item>
		
			<item>
				<title>Python 反射机制</title>
				<description>&lt;p&gt;Python 反射机制简单介绍和适用场景。&lt;/p&gt;

&lt;h2 id=&quot;python&quot;&gt;Python的反射机制&lt;/h2&gt;

&lt;p&gt;在获取一个类或模块的某个属性时，通常需要在代码中直接指定属性名，如：   &lt;/p&gt;

&lt;p&gt;```python
class MyClass(object):
    int a
    float b
    string c&lt;/p&gt;

&lt;p&gt;c = MyClass()&lt;/p&gt;

&lt;p&gt;print c.a&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;但如果我们不知道属性名呢？比如属性名是在代码中动态生成并存在某个变量中。在这种情况下就需要借助python的反射机制了。&lt;/p&gt;

&lt;h2 id=&quot;hasattr-getattr-setattr&quot;&gt;hasattr, getattr, setattr&lt;/h2&gt;

&lt;p&gt;python代码可以通过三个内置函数来实现反射：hasattr, getattr, setattr&lt;/p&gt;

&lt;p&gt;```python&lt;/p&gt;

&lt;p&gt;class MyClass(object):
    a = 0
    b = 1&lt;/p&gt;

&lt;p&gt;c = MyClass()&lt;/p&gt;

&lt;p&gt;myattr = ‘a’
new_value = 123&lt;/p&gt;

&lt;p&gt;if hasattr(c, myattr):
    val = getattr(c, myattr)
    print ‘Old attribute: %s’ % val&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setattr(c, myattr, new_value)
val = getattr(c, myattr)
print &#39;New attribute: %s&#39; % val
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h2 id=&quot;evalgetattr&quot;&gt;使用eval实现getattr&lt;/h2&gt;

&lt;p&gt;内置函数eval可以将一段字符串当做python表达式处理，灵活使用eval函数也可以部分实现反射的功能：&lt;/p&gt;

&lt;p&gt;```python&lt;/p&gt;

&lt;p&gt;class MyClass(object):
    a = 0
    b = 1&lt;/p&gt;

&lt;p&gt;c = MyClass()&lt;/p&gt;

&lt;p&gt;myattr = ‘a’
new_value = 123&lt;/p&gt;

&lt;p&gt;val = eval(‘c.%s’ % myattr)
print val&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h2 id=&quot;callable-dir&quot;&gt;使用callable, dir获得额外信息&lt;/h2&gt;

&lt;p&gt;内置函数callable可以帮助判断一个属性是否是个函数&lt;/p&gt;

&lt;p&gt;```python&lt;/p&gt;

&lt;p&gt;class MyClass(object):
    a = 0
    b = 1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def myfunc(self):
    pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;c = MyClass()&lt;/p&gt;

&lt;p&gt;myattr = ‘myfunc’&lt;/p&gt;

&lt;p&gt;if hasattr(c, myattr):
    myfunc = getattr(c, myattr)
    if callable(myfunc):
        myfunc()&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;内置函数dir可以帮助列出一个类的所有属性&lt;/p&gt;

&lt;p&gt;```python&lt;/p&gt;

&lt;p&gt;class MyClass(object):
    a = 0
    b = 1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def myfunc(self):
    pass
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;blockquote&gt;
      &lt;p&gt;c = MyClass()
dir(c)
[‘&lt;strong&gt;class&lt;/strong&gt;’, ‘&lt;strong&gt;delattr&lt;/strong&gt;’, ‘&lt;strong&gt;dict&lt;/strong&gt;’, ‘&lt;strong&gt;doc&lt;/strong&gt;’, ‘&lt;strong&gt;format&lt;/strong&gt;’, ‘&lt;strong&gt;getattribute&lt;/strong&gt;’, ‘&lt;strong&gt;hash&lt;/strong&gt;’, ‘&lt;strong&gt;init&lt;/strong&gt;’, ‘&lt;strong&gt;module&lt;/strong&gt;’, ‘&lt;strong&gt;new&lt;/strong&gt;’, ‘&lt;strong&gt;reduce&lt;/strong&gt;’, ‘&lt;strong&gt;reduce_ex&lt;/strong&gt;’, ‘&lt;strong&gt;repr&lt;/strong&gt;’, ‘&lt;strong&gt;setattr&lt;/strong&gt;’, ‘&lt;strong&gt;sizeof&lt;/strong&gt;’, ‘&lt;strong&gt;str&lt;/strong&gt;’, ‘&lt;strong&gt;subclasshook&lt;/strong&gt;’, ‘&lt;strong&gt;weakref&lt;/strong&gt;’, ‘a’, ‘b’]&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;```&lt;/p&gt;
</description>
				<pubDate>Mon, 02 May 2016 12:18:00 +0800</pubDate>
				<link>http://www.arthurmao.me/2016/05/python-getattr-modules</link>
				<guid isPermaLink="true">http://www.arthurmao.me/2016/05/python-getattr-modules</guid>
			</item>
		
			<item>
				<title>CentOS安装Redis数据库</title>
				<description>&lt;p&gt;Redis安装笔记&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;安装依赖包&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;bash
yum install gcc
yum install tcl
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;下载安装包&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;bash
wget http://download.redis.io/releases/redis-stable.tar.gz
cd redis-stable
make MALLOC=libc
make test
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;复制命令行和配置文件&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;bash
ln -s ~/redis-stable/src/redis-server /usr/local/bin/redis-server
ln -s ~/redis-stable/src/redis-cli /usr/local/bin/redis-cli
mkdir /etc/redis
cp ~/redis-stable/redis.conf /etc/redis/redis.conf
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;操作&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;bash
## 启动
redis-server &amp;amp;
## 连接
redis-cli
## 关闭
redis-cli
shutdown
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;python-&quot;&gt;python 包&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;bash
## 安装
python -m pip install redis
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;```python&lt;/p&gt;

&lt;p&gt;import redis&lt;/p&gt;

&lt;p&gt;r = redis.Redis(host=’192.168.111.211’, port=6379, db=1)
print(r.info())&lt;/p&gt;

&lt;h2 id=&quot;string&quot;&gt;string&lt;/h2&gt;
&lt;p&gt;r[‘name’] = ‘Arthur’
print(r[‘name’])&lt;/p&gt;

&lt;h2 id=&quot;list&quot;&gt;list&lt;/h2&gt;
&lt;p&gt;r.lpush(‘listtest’, ‘aaa’)
r.lpush(‘listtest’, ‘bbb’)
r.lrange(‘listtest’, start=0, end=-1)
r.lindex(‘listtest’, 0)&lt;/p&gt;

&lt;h2 id=&quot;set&quot;&gt;set&lt;/h2&gt;
&lt;p&gt;r.sadd(‘settest’, ‘aa’)
r.sadd(‘settest’, ‘aa’)
r.sadd(‘settest’, ‘bb’)
r.sadd(‘settest1’, ‘bb’)
r.smembers(‘settest’)
r.sinter(‘settest’,’settest1’) ## 交集
r.sunion(‘s1’,’s2’) ## 并集
r.sdiff(‘settest’,’settest1’) ## 不同&lt;/p&gt;

&lt;h2 id=&quot;hash&quot;&gt;hash&lt;/h2&gt;
&lt;p&gt;r.hset(‘hashtest’, ‘name’, ‘Arthur’)
r.hset(‘hashtest’, ‘age’, ‘25’)
r.hgetall(‘hashtest’)
r.hget(‘hashtest’, ‘name’)
```&lt;/p&gt;
</description>
				<pubDate>Sat, 23 Apr 2016 15:24:00 +0800</pubDate>
				<link>http://www.arthurmao.me/2016/04/install-redis-centos</link>
				<guid isPermaLink="true">http://www.arthurmao.me/2016/04/install-redis-centos</guid>
			</item>
		
			<item>
				<title>使用pdb来debug python程序</title>
				<description>&lt;p&gt;Python的命令行debug程序pdb笔记&lt;/p&gt;

&lt;h2 id=&quot;pdbpython&quot;&gt;使用PDB打开python脚本&lt;/h2&gt;

&lt;p&gt;```python
‘’’
方法1：使用python -m pdb &lt;your script=&quot;&quot;&gt;
相当于在第一行程序之前设置一个断点
&#39;&#39;&#39;
$ python -m pdb test.py
&amp;gt; /root/test.py(3)&lt;module&gt;()
-&amp;gt; import sys,os&lt;/module&gt;&lt;/your&gt;&lt;/p&gt;

&lt;p&gt;’’’
方法2：在程序代码中添加pdb断点
比方法1方便，但是会更改源程序，调试完得全部删除
‘’’
import pdb&lt;/p&gt;

&lt;p&gt;print(‘hello’)
pdb.set_trace()
print(‘world’)
```&lt;/p&gt;

&lt;h2 id=&quot;pdb&quot;&gt;pdb常用命令&lt;/h2&gt;

&lt;p&gt;```
h =&amp;gt; 显示帮助，h后面可以跟上具体的指令来显示该指令的文档
l =&amp;gt; 浏览代码，默认是从第一行开始的11行，连续使用可以翻页。可以添加参数l(ist) [first [,last]]，比如l 0能回到行首。
b =&amp;gt; 设置断点，后面跟行号，会回显断点号
cl =&amp;gt; 清除断点，后面跟断点号可以清除指定的断点
disable =&amp;gt; 禁用断点，用法如cl，用enable解禁
n =&amp;gt; 下一行。不进入函数体
s =&amp;gt; 下一行，进入函数体
c =&amp;gt; 执行程序直到断点
p =&amp;gt; 后跟变量，打印变量值&lt;/p&gt;

&lt;p&gt;TIPS：在pdb中直接回车一般会执行上一条指令，可以更方便的用n/s跟踪程序或者用l翻页查看
```&lt;/p&gt;
</description>
				<pubDate>Sat, 05 Mar 2016 22:29:00 +0800</pubDate>
				<link>http://www.arthurmao.me/2016/03/python-pdb-debug</link>
				<guid isPermaLink="true">http://www.arthurmao.me/2016/03/python-pdb-debug</guid>
			</item>
		
			<item>
				<title>Linux下实现彩色/动态的命令行输出</title>
				<description>&lt;p&gt;做项目有实时、动态显示结果的需求，并且要用红色高亮错误，记录一下实现方法&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;彩色输出&lt;/h2&gt;

&lt;p&gt;SHELL本身可以通过ANSI控制码来控制输出字体的格式，具体格式如下：    &lt;/p&gt;

&lt;p&gt;&lt;code&gt;bash
\033[&amp;lt;字体格式&amp;gt;;&amp;lt;前景色&amp;gt;;&amp;lt;背景色&amp;gt;m&amp;lt;输出&amp;gt;\033[0m
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在shell脚本中直接echo或者在python中按照上述格式print，就能显示对应的效果。 &lt;br /&gt;
基于这个原理我写了一个简单的python函数，在需要彩色输出的时候给出对应的参数就可以了：   &lt;/p&gt;

&lt;p&gt;&lt;code&gt;python
def color_print(msg, fcolor=&#39;white&#39;, bcolor=&#39;black&#39;, mode=&#39;normal&#39;, end=None):
    fcolor_map = {
        &#39;black&#39;: 30,
        &#39;red&#39;: 31,
        &#39;green&#39;: 32,
        &#39;yellow&#39;: 33,
        &#39;blue&#39;: 34,
        &#39;purple&#39;: 35,
        &#39;cyan&#39;: 36,
        &#39;white&#39;: 37,
    }
    bcolor_map = {
        &#39;black&#39;: 40,
        &#39;red&#39;: 41,
        &#39;green&#39;: 42,
        &#39;yellow&#39;: 43,
        &#39;blue&#39;: 44,
        &#39;purple&#39;: 45,
        &#39;cyan&#39;: 46,
        &#39;white&#39;: 47,
    }
    mode_map = {
        &#39;normal&#39;: 0,
        &#39;bold&#39;: 1,
        &#39;underline&#39;: 4,
        &#39;blink&#39;: 5,
        &#39;invert&#39;: 7,
        &#39;hide&#39;: 8,
    }
    msg = &#39;\033[%(mode)s;%(fcolor)s;%(bcolor)sm%(msg)s\033[0m&#39; % {
        &#39;mode&#39;: mode,
        &#39;fcolor&#39;: fcolor,
        &#39;bcolor&#39;: bcolor,
        &#39;msg&#39;: msg,
    }
    if (not end):
        print(msg)
    else:
        print(msg,end=end)
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;动态输出&lt;/h2&gt;

&lt;p&gt;在我上面的代码中用到了print函数中的end选项，这个是python3.x中print函数非常实用的一个选项，简单来讲就是替换掉print的结束符–在默认情况下实用print都会在结尾自动跟一个换行符。   &lt;/p&gt;

&lt;p&gt;所以如果你不希望print换行，就可以&lt;code&gt;print(msg,end=&#39;&#39;)&lt;/code&gt;，而为了实现动态输出，我们需要在print完之后将光标移到行首，对应的转移字符就是&lt;code&gt;\r&lt;/code&gt;，因此使用&lt;code&gt;print(msg,end=&#39;\r&#39;)&lt;/code&gt;就可以让光标在每次print完后回到行首了。  &lt;br /&gt;
另外在print完后记得使用&lt;code&gt;sys.stdout.flush()&lt;/code&gt;来及时显示信息。      &lt;/p&gt;

&lt;p&gt;一些TIPS：   &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在python2中可以通过&lt;code&gt;from __future__ import print_function&lt;/code&gt;来使用python3的print功能。&lt;/li&gt;
  &lt;li&gt;在动态刷新当前行的时候，如果前一行的字符串比较长，多出来的部分不会被清掉，记得在结尾补上空白符来清除。&lt;/li&gt;
&lt;/ul&gt;
</description>
				<pubDate>Sat, 20 Feb 2016 17:53:00 +0800</pubDate>
				<link>http://www.arthurmao.me/2016/02/art-of-print</link>
				<guid isPermaLink="true">http://www.arthurmao.me/2016/02/art-of-print</guid>
			</item>
		
			<item>
				<title>实用的Linux/Shell命令之：awk sed</title>
				<description>&lt;p&gt;awk和sed是Linux下非常实用的文本处理工具，整理一下常见用法&lt;/p&gt;

&lt;h2 id=&quot;awksed&quot;&gt;awk和sed的区别&lt;/h2&gt;

&lt;p&gt;通常来讲，awk用来处理同一行中的数据，sed用来处理不同行之间的数据，一个横向一个纵向。&lt;/p&gt;

&lt;h2 id=&quot;awksed-1&quot;&gt;awk和sed的常用参数&lt;/h2&gt;

&lt;p&gt;网上有很多文档这里就不再多写了，比如可以参考：   &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;sed: http://www.iteye.com/topic/587673&lt;/li&gt;
  &lt;li&gt;awk: http://www.cnblogs.com/ggjucheng/archive/2013/01/13/2858470.html&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;常见用法&lt;/h2&gt;

&lt;p&gt;我在做Support时候经常遇到一种情况，需要查看不同端口报错数的分布，例如如下日志：   &lt;/p&gt;

&lt;p&gt;&lt;code&gt;bash
# test.log
2015-01-01 A1-FC00 GOOD
2015-01-04 B1-FC00 ERROR
2015-01-05 B1-FC00 GOOD
2015-01-05 A1-FC00 ERROR
2015-01-11 A1-FC00 ERROR
2015-01-22 A1-FC00 GOOD
2015-02-01 C1-FC00 ERROR
2015-02-01 B1-FC00 ERROR
2015-02-02 A1-FC00 ERROR
2015-02-05 C1-FC00 GOOD
2015-02-06 A1-FC00 ERROR
2015-02-11 A1-FC00 ERROR
2015-02-11 C1-FC00 GOOD
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;那么如何快速统计出各个端口的报错情况呢？这样：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bash
$ grep ERROR test.log | awk &#39;{print $2}&#39; | sort | uniq -c | sort -rn
      5 A1-FC00
      2 B1-FC00
      1 C1-FC00
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;统计时间分布也是类似的：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bash
$ grep ERROR test.log | awk &#39;{print $1}&#39; | sort | uniq -c | sort -rn
      2 2015-02-01
      1 2015-02-11
      1 2015-02-06
      1 2015-02-02
      1 2015-01-11
      1 2015-01-05
      1 2015-01-04
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果我们希望统计1月和2月的报错总数：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bash
$ grep ERROR test.log | awk &#39;{print $1}&#39; | awk -F &#39;-&#39; &#39;{print $1&quot;-&quot;$2}&#39; | sort | uniq -c | sort -rn
      5 2015-02
      3 2015-01
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果我们希望统计1月5号到2月5号之间的数据就需要使用sed了&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bash
$ sed -n &#39;/2015-01-05/,/2015-02-05/p&#39; test.log | grep ERROR | awk &#39;{print $1}&#39; | sort | uniq -c | sort -rn
      2 2015-02-01
      1 2015-02-02
      1 2015-01-11
      1 2015-01-05
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;但其实这样做比较麻烦，而且如果日志中没有2月5号的数据就会出问题，实际情况中由于日志都是按时间戳顺序记录的，因此可以人工查看日志文件，找到对应的行号，比如第一个1月5号的记录在日志第三行，最后一个2月5号的记录在日志第十行，那么我们就可以用sed把3~10行的数据抓出来，免去匹配时间戳的麻烦。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bash
$ sed -n &#39;3,10p&#39; test.log | grep ERROR | awk &#39;{print $1}&#39; | sort | uniq -c | sort -rn
      2 2015-02-01
      1 2015-02-02
      1 2015-01-11
      1 2015-01-05
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使用sed进行批量替换，比如我们想把端口A1-FC00替换成67，B1-FC00替换成68，C1-FC00替换成69：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bash
$ grep ERROR test.log | awk &#39;{print $2}&#39; | sort | uniq -c | sort -rn | sed &#39;s/A1-FC00/67/g&#39; | sed &#39;s/B1-FC00/68/g&#39; | sed &#39;s/C1-FC00/69/g&#39;
      5 67
      2 68
      1 69
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;另外在我另一篇博文&lt;a href=&quot;http://www.arthurmao.me/2015/10/replace-zypper-repo&quot;&gt;OpenSUSE配置国内源&lt;/a&gt; 中就使用了sed，配合find和xargs完成了对配置文件的批量替换更改：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bash
$ find . -name &quot;repo*&quot; | sed &#39;s/.\///g&#39; | xargs -i sh -c &quot;cat {} | sed &#39;s/download.opensuse.org/mirrors.zju.edu.cn\/opensuse/g&#39; | sed &#39;s/repo-/zju\/repo-/g&#39; | sed &#39;s/openSUSE-13.2/zju\/openSUSE-13.2/g&#39; &amp;gt; zju-{}&quot;
&lt;/code&gt;&lt;/p&gt;

</description>
				<pubDate>Sat, 13 Feb 2016 11:01:00 +0800</pubDate>
				<link>http://www.arthurmao.me/2016/02/awk-sed</link>
				<guid isPermaLink="true">http://www.arthurmao.me/2016/02/awk-sed</guid>
			</item>
		
			<item>
				<title>Python的闭包和装饰器</title>
				<description>&lt;p&gt;Python的闭包和装饰器整理&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;什么是闭包/装饰器？&lt;/h2&gt;

&lt;p&gt;用我自己的理解来讲：   &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;闭包：一个函数，它的作用是通过输入参数构造另一个函数&lt;/li&gt;
  &lt;li&gt;装饰器：输入参数是一个函数的闭包，可以用语法糖@xxx来使用   &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;举点栗子&lt;/p&gt;

&lt;p&gt;```python
‘’’
闭包例子。实现了一个简单的html标签函数
‘’’
def func_maker(tag):
    def _func(msg):
        return ‘&amp;lt;%(tag)s&amp;gt;msg&amp;lt;/%(tag)s&amp;gt;’ % {‘tag’: tag}
    return _func&lt;/p&gt;

&lt;p&gt;html_maker = func_maker(‘html’)
div_maker = func_maker(‘div’)&lt;/p&gt;

&lt;p&gt;print html_maker(div_maker(‘Div Content’))&lt;/p&gt;

&lt;p&gt;’’’
装饰器例子。实现了一个简单的函数运行时间统计
‘’’
import sys, os
import time
from datetime import datetime, timedelta
def runtime(fmt):
    def _runtime(func):
        def _func(&lt;em&gt;args, **kwargs):
            start_ts = datetime.now()
            func(&lt;/em&gt;args, **kwargs)
            end_ts = datetime.now()
            delta = end_ts - start_ts
            print ‘start time: %s’ % datetime.strftime(start_ts, fmt)
            print ‘runtime: %s’ % delta
        return _func
    return _runtime&lt;/p&gt;

&lt;p&gt;@runtime(‘%Y-%m-%d %H:%M:%S’)
def testfunc1(sec):
    time.sleep(sec)&lt;/p&gt;

&lt;p&gt;@runtime(‘%H:%M:%S’)
def testfunc2(sec):
    time.sleep(sec)&lt;/p&gt;

&lt;p&gt;testfunc1(3)
testfunc2(5)
```&lt;/p&gt;
</description>
				<pubDate>Sat, 06 Feb 2016 21:33:00 +0800</pubDate>
				<link>http://www.arthurmao.me/2016/02/closure-and-decorator</link>
				<guid isPermaLink="true">http://www.arthurmao.me/2016/02/closure-and-decorator</guid>
			</item>
		
			<item>
				<title>Python的多线程与多进程</title>
				<description>&lt;p&gt;Python的多线程与多进程整理&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;多线程与多进程的区别和适用场景&lt;/h2&gt;

&lt;p&gt;一般来讲多线程比多进程更轻量，消耗资源更少，因为线程之间是共享内存的而进程都拥有自己独立的内存。 &lt;br /&gt;
但是Python(CPython)在多线程的实现方面受限与GIL，在执行CPU密集型程序时并不能体现出优势，所以对于这类程序通常使用多进程实现。
另外python的threading模块并没有实现kill/terminate之类的强制退出方法，自己实现的话比较ugly，所以对于那些无法通过设置标志位退出的程序还是用multiprocess比较方便。  &lt;/p&gt;

&lt;h2 id=&quot;pythonthreading&quot;&gt;python的多线程模块threading&lt;/h2&gt;

&lt;p&gt;官方文档：https://docs.python.org/2.7/library/threading.html &lt;br /&gt;
一个简单的示例程序：&lt;/p&gt;

&lt;p&gt;```python
import sys, os
import time
from datetime import datetime, timedelta
import threading
‘’’
Queue.Queue是一个线程安全队列，非常适合用于线程间数据传递以及生产者消费者模型
‘’’
from Queue import Queue&lt;/p&gt;

&lt;p&gt;def threadTask(qin, qout):
    ‘’’
    threading.current_thread =&amp;gt; 获取当前线程的实例
    ‘’’
    cur_thd = threading.current_thread()
    while qin.qsize() &amp;gt; 0:
        inputs = qin.get()
        print(‘Thread %s is running…’ % cur_thd.ident)
        print(‘Accept input: %s’ % inputs)
        print(‘Sleeping %s seconds’ % inputs)
        time.sleep(inputs)
        qout.put(inputs+1)
    print(‘Thread %s is exiting…’ % cur_thd.ident)&lt;/p&gt;

&lt;p&gt;def main():
    inputs = [2,3,4,60,70]
    qin = Queue()
    for i in inputs:
        qin.put(i)
    qout = Queue()
    thd_list = []
    for i in range(3):
        thd = threading.Thread(target=threadTask, kwargs = {
            ‘qin’: qin,
            ‘qout’: qout,
        })
        ‘’’
        设置为守护线程：当主线程结束时自动终止这些线程
        如果没有设置daemon=True，当timeout发生后由于子线程仍未退出，主线程会继续等待
        ‘’’
        thd.daemon = True
        thd.start()
        thd_list.append(thd)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for thd in thd_list:
    &#39;&#39;&#39;
    join =&amp;gt; 主线程阻塞在此处等待子线程结束，可设置timeout。
    timeout发生后主线程取消阻塞，但子线程依然在后台执行
    &#39;&#39;&#39;
    thd.join(5)
    &#39;&#39;&#39;
    threading.is_alive可以用来判断子线程是超时退出还是超时退出
    &#39;&#39;&#39;
    if (thd.is_alive()):
        print(&#39;Thread %s is timeout!!&#39; % thd.ident)

&#39;&#39;&#39;
从qout中获取输出
&#39;&#39;&#39;
while qout.qsize():
    out = qout.get()
    print(&#39;=&amp;gt; %s&#39; % out)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;if &lt;strong&gt;name&lt;/strong&gt; == ‘&lt;strong&gt;main&lt;/strong&gt;’:
    main()
```&lt;/p&gt;

&lt;p&gt;另一种实现方法–继承threading.Thread类并重写run函数&lt;/p&gt;

&lt;p&gt;```python
class MyThread(threading.Thread):
    qin = None
    qout = None
    def &lt;strong&gt;init&lt;/strong&gt;(self, qin, qout):
        self.qin = qin
        self.qout = qout
        threading.Thread.&lt;strong&gt;init&lt;/strong&gt;(self)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def run(self):
    while self.qin.qsize() &amp;gt; 0:
        inputs = self.qin.get()
        print(&#39;Thread %s is running...&#39; % self.ident)
        print(&#39;Accept input: %s&#39; % inputs)
        print(&#39;Sleeping %s seconds&#39; % inputs)
        time.sleep(inputs)
        self.qout.put(inputs+1)
    print(&#39;Thread %s is exiting...&#39; % self.ident)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;def main():
    inputs = [3,4,50,60,70]
    qin = Queue()
    for i in inputs:
        qin.put(i)
    qout = Queue()
    thd_list = []
    for i in range(3):
        thd = MyThread(qin, qout)
        thd.daemon = True
        thd.start()
        thd_list.append(thd)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for thd in thd_list:
    thd.join(5)
    if (thd.isAlive()):
        print(&#39;Thread %s is timeout!!&#39; % thd.ident)

while qout.qsize():
    out = qout.get()
    print(&#39;=&amp;gt; %s&#39; % out)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;if &lt;strong&gt;name&lt;/strong&gt; == ‘&lt;strong&gt;main&lt;/strong&gt;’:
    main()
```&lt;/p&gt;

&lt;h2 id=&quot;pythonmultiprocessing&quot;&gt;python的多进程模块multiprocessing&lt;/h2&gt;

&lt;p&gt;Python的multiprocessing模块可以用类似多线程的方法实现多进程
官方文档：https://docs.python.org/2.7/library/multiprocessing.html&lt;/p&gt;

&lt;p&gt;```python
import sys, os
import time
from datetime import datetime, timedelta
import threading
import multiprocessing
‘’’
用multiprocessing.Queue替换Queue.Queue
‘’’
# from Queue import Queue
from multiprocessing import Queue&lt;/p&gt;

&lt;p&gt;def processTask(qin, qout):
    while qin.qsize() &amp;gt; 0:
        ‘’’
        os.getpid()直接可以获取当前进程的进程号
        ‘’’
        print(‘Process %s is running…’ % os.getpid())
        inputs = qin.get()
        print(‘Accept input: %s’ % inputs)
        print(‘Sleeping %s seconds’ % inputs)
        time.sleep(inputs)
        qout.put(inputs+1)
    print(‘Process %s is exiting…’ % os.getpid())&lt;/p&gt;

&lt;p&gt;def main():
    inputs = [2,3,4,60,70]
    qin = Queue()
    for i in inputs:
        qin.put(i)
    qout = Queue()
    proc_list = []
    for i in range(3):
        proc = multiprocessing.Process(target=processTask, kwargs={
            ‘qin’: qin,
            ‘qout’: qout,
        })
        proc.deamon = True
        proc.start()
        ‘’’
        用proc.pid获取子进程进程号
        ‘’’
        print(‘Start process %s’ % proc.pid)
        proc_list.append(proc)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for proc in proc_list:
    proc.join(5)
    if (proc.is_alive()):
        print(&#39;Process %s is timeout!!&#39; % proc.pid)
        &#39;&#39;&#39;
        子进程是可以强制终止的，这点比线程好
        &#39;&#39;&#39;
        proc.terminate()

while qout.qsize():
    out = qout.get()
    print(&#39;=&amp;gt; %s&#39; % out)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;if &lt;strong&gt;name&lt;/strong&gt; == ‘&lt;strong&gt;main&lt;/strong&gt;’:
    main()
```&lt;/p&gt;

&lt;h2 id=&quot;lock&quot;&gt;Lock机制&lt;/h2&gt;

&lt;p&gt;threading和multiprocessing还提供了各种的Lock机制，但在实际编程中大部分同步问题用Queue就能解决了，这里就简单记录一下。&lt;/p&gt;

&lt;p&gt;```python
‘’’
基本锁
‘’’
threading.Lock/multiprocess.Lock &lt;/p&gt;

&lt;p&gt;’’’
RLock，和Lock的区别在于允许同一线程内多次require而不会死锁
多次require RLock也需要多次release，直到所有的锁被释放
‘’’
threading.RLock/multiprocess.RLock&lt;/p&gt;

&lt;p&gt;’’’
Condition，比较高级的锁，支持notify，wait等较复杂的同步
‘’’
threading.Condition/multiprocess.Condition
```&lt;/p&gt;
</description>
				<pubDate>Sat, 23 Jan 2016 17:06:00 +0800</pubDate>
				<link>http://www.arthurmao.me/2016/01/multithread-and-multiprocess</link>
				<guid isPermaLink="true">http://www.arthurmao.me/2016/01/multithread-and-multiprocess</guid>
			</item>
		
			<item>
				<title>Python subprocess模块</title>
				<description>&lt;p&gt;Python subprocess通常用来调用并获得shell指令的输出，这里整理一下用法.
官方文档：https://docs.python.org/2.7/library/subprocess.html&lt;/p&gt;

&lt;h2 id=&quot;subprocess-&quot;&gt;subprocess 模块的基本用法&lt;/h2&gt;

&lt;p&gt;```python
import subprocess&lt;/p&gt;

&lt;p&gt;cmd = ‘’’ echo “Your shell command” ‘’’
p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
res, err = p.communicate()&lt;/p&gt;

&lt;p&gt;’’’
设置shell=True会存在shell injection的安全隐患，出于安全性考虑可以这么用
‘’’
cmd = [‘echo’, ‘“Your shell command”’]
p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
res, err = p.communicate()
```&lt;/p&gt;

&lt;h2 id=&quot;subprocess&quot;&gt;使用subprocess动态获取输出&lt;/h2&gt;

&lt;p&gt;有时候我们需要实时跟踪一个指令的输出，比如监控一个长ping的结果：&lt;/p&gt;

&lt;p&gt;```python
import subprocess&lt;/p&gt;

&lt;p&gt;cmd = ‘’’ ping localhost -c 5 ‘’’
p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
while True:
    out = p.stdout.readline()
    if (out == ‘’):
        break
    print ‘Am in subprocess =&amp;gt; %s’ % out
```&lt;/p&gt;

&lt;h2 id=&quot;python2-vs-python3&quot;&gt;Python2 VS Python3&lt;/h2&gt;

&lt;p&gt;Python3对subprocess模块有了一些很不错的改进，比如：  &lt;/p&gt;

&lt;p&gt;```python
‘’’
1. Python3 支持context manager：通过dir指令可以看出Python3的subprocess模块存在__enter__和__exit__函数
‘’’
# python2
Python 2.7.9 (default, Nov 14 2015, 17:52:58)
[GCC 4.8.3 20140911 (Red Hat 4.8.3-9)] on linux2
Type “help”, “copyright”, “credits” or “license” for more information.
»&amp;gt; import subprocess
»&amp;gt; dir(subprocess.Popen)
[‘&lt;strong&gt;class&lt;/strong&gt;’, ‘&lt;strong&gt;del&lt;/strong&gt;’, ‘&lt;strong&gt;delattr&lt;/strong&gt;’, ‘&lt;strong&gt;dict&lt;/strong&gt;’, ‘&lt;strong&gt;doc&lt;/strong&gt;’, ‘&lt;strong&gt;format&lt;/strong&gt;’, ‘&lt;strong&gt;getattribute&lt;/strong&gt;’, ‘&lt;strong&gt;hash&lt;/strong&gt;’, ‘&lt;strong&gt;init&lt;/strong&gt;’, ‘&lt;strong&gt;module&lt;/strong&gt;’, ‘&lt;strong&gt;new&lt;/strong&gt;’, ‘&lt;strong&gt;reduce&lt;/strong&gt;’, ‘&lt;strong&gt;reduce_ex&lt;/strong&gt;’, ‘&lt;strong&gt;repr&lt;/strong&gt;’, ‘&lt;strong&gt;setattr&lt;/strong&gt;’, ‘&lt;strong&gt;sizeof&lt;/strong&gt;’, ‘&lt;strong&gt;str&lt;/strong&gt;’, ‘&lt;strong&gt;subclasshook&lt;/strong&gt;’, ‘&lt;strong&gt;weakref&lt;/strong&gt;’, ‘_child_created’, ‘_close_fds’, ‘_communicate’, ‘_communicate_with_poll’, ‘_communicate_with_select’, ‘_execute_child’, ‘_get_handles’, ‘_handle_exitstatus’, ‘_internal_poll’, ‘_set_cloexec_flag’, ‘_translate_newlines’, ‘communicate’, ‘kill’, ‘pipe_cloexec’, ‘poll’, ‘send_signal’, ‘terminate’, ‘wait’]&lt;/p&gt;

&lt;h1 id=&quot;python3&quot;&gt;python3&lt;/h1&gt;
&lt;p&gt;Python 3.4.3 (default, Nov 14 2015, 18:34:36)
[GCC 4.8.3 20140911 (Red Hat 4.8.3-9)] on linux
Type “help”, “copyright”, “credits” or “license” for more information.
»&amp;gt; import subprocess
»&amp;gt; dir(subprocess.Popen)
[‘&lt;strong&gt;class&lt;/strong&gt;’, ‘&lt;strong&gt;del&lt;/strong&gt;’, ‘&lt;strong&gt;delattr&lt;/strong&gt;’, ‘&lt;strong&gt;dict&lt;/strong&gt;’, ‘&lt;strong&gt;dir&lt;/strong&gt;’, ‘&lt;strong&gt;doc&lt;/strong&gt;’, ‘&lt;strong&gt;enter&lt;/strong&gt;’, ‘&lt;strong&gt;eq&lt;/strong&gt;’, ‘&lt;strong&gt;exit&lt;/strong&gt;’, ‘&lt;strong&gt;format&lt;/strong&gt;’, ‘&lt;strong&gt;ge&lt;/strong&gt;’, ‘&lt;strong&gt;getattribute&lt;/strong&gt;’, ‘&lt;strong&gt;gt&lt;/strong&gt;’, ‘&lt;strong&gt;hash&lt;/strong&gt;’, ‘&lt;strong&gt;init&lt;/strong&gt;’, ‘&lt;strong&gt;le&lt;/strong&gt;’, ‘&lt;strong&gt;lt&lt;/strong&gt;’, ‘&lt;strong&gt;module&lt;/strong&gt;’, ‘&lt;strong&gt;ne&lt;/strong&gt;’, ‘&lt;strong&gt;new&lt;/strong&gt;’, ‘&lt;strong&gt;reduce&lt;/strong&gt;’, ‘&lt;strong&gt;reduce_ex&lt;/strong&gt;’, ‘&lt;strong&gt;repr&lt;/strong&gt;’, ‘&lt;strong&gt;setattr&lt;/strong&gt;’, ‘&lt;strong&gt;sizeof&lt;/strong&gt;’, ‘&lt;strong&gt;str&lt;/strong&gt;’, ‘&lt;strong&gt;subclasshook&lt;/strong&gt;’, ‘&lt;strong&gt;weakref&lt;/strong&gt;’, ‘_check_timeout’, ‘_child_created’, ‘_close_fds’, ‘_communicate’, ‘_execute_child’, ‘_get_devnull’, ‘_get_handles’, ‘_handle_exitstatus’, ‘_internal_poll’, ‘_remaining_time’, ‘_save_input’, ‘_translate_newlines’, ‘_try_wait’, ‘communicate’, ‘kill’, ‘poll’, ‘send_signal’, ‘terminate’, ‘wait’]&lt;/p&gt;

&lt;h1 id=&quot;python3popen&quot;&gt;因此在Python3中，正确打开一个Popen的姿势应该是这样的&lt;/h1&gt;
&lt;p&gt;with subprocess.Popen(cmd) as p:
    res,err = p.communicate()&lt;/p&gt;

&lt;p&gt;’’’
2. Python3 中的subprocess支持timeout选项，在执行可能会hung的指令时非常有用！
‘’’
cmd = ‘’’ sleep 10 ‘’’
with subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) as p:
    try:
         out,res = p.communicate(timeout=5)
     except subprocess.TimeoutExpired:
         p.kill()
         print(‘Command timeout!!’)&lt;/p&gt;

&lt;p&gt;’’’
3. Python3中subprocess的返回值是byte，如果要用作string的话需要做个转换
‘’’
cmd = ‘’’ echo “hello” ‘’’
with subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) as p:
    try:
         out,res = p.communicate(timeout=5)
         out = out.decode()
         print(out)
     except subprocess.TimeoutExpired:
         p.kill()
         print(‘Command timeout!!’)&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;
</description>
				<pubDate>Sat, 16 Jan 2016 21:02:00 +0800</pubDate>
				<link>http://www.arthurmao.me/2016/01/python-subprocess</link>
				<guid isPermaLink="true">http://www.arthurmao.me/2016/01/python-subprocess</guid>
			</item>
		
			<item>
				<title>Python argparse模块</title>
				<description>&lt;p&gt;Python有很多命令行选项相关的模块，比如getopt, optparse等，各种都用过一下后感觉还是argparse最方便最轻量。  &lt;br /&gt;
官方详细文档：  https://docs.python.org/2.7/library/argparse.html&lt;/p&gt;

&lt;h2 id=&quot;argparse-&quot;&gt;argparse 模块的基本用法&lt;/h2&gt;

&lt;p&gt;```python
import logging&lt;/p&gt;

&lt;p&gt;’’’
第一步：创建parser实例
‘’’
parser = argparse.ArgumentParser(description=’Write overall help message here’)&lt;/p&gt;

&lt;p&gt;’’’
第二步：创建参数和选项
‘’’
parser.add_argument(‘myargs’, nargs=’+’, 
    help=’My arguments’)
parser.add_argument(‘-o’, ‘–myopts’, default=’hello’
    help=’My options’)
parser.add_argument(‘-f’, ‘–myflag’, action=’store_true’
    help=’My flag’)&lt;/p&gt;

&lt;p&gt;’’’
第三步：获取参数
‘’’
args = parser.parse_args()
myargs = args.myargs
myopts = args.myopts
myflag = args.myflag
```&lt;/p&gt;

&lt;h2 id=&quot;argparse--1&quot;&gt;argparse 实用选项&lt;/h2&gt;

&lt;p&gt;以下是一些常见的参数，通常已经能满足一般命令行工具的需求了。&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;default：参数默认值。&lt;/p&gt;

&lt;p&gt;nargs: 参数个数，若有多个参数则用空格分隔
注意如果有配置nargs（哪怕nargs=1），那么拿到的参数是一个list，否则就是一个值&lt;/p&gt;

&lt;p&gt;action：执行操作，通常设置为store_true用于无需接受参数的选项比如–debug这种。&lt;/p&gt;

&lt;p&gt;type：输入值的类型，其实就是帮你做了一个显示类型转换，不指定的话默认是string&lt;/p&gt;

&lt;p&gt;choice：限制输入值的种类，例如choice=[‘choiceA’, ‘choiceB’]&lt;/p&gt;

&lt;p&gt;help：简单说明&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;
</description>
				<pubDate>Sun, 03 Jan 2016 11:09:00 +0800</pubDate>
				<link>http://www.arthurmao.me/2016/01/python-argparse</link>
				<guid isPermaLink="true">http://www.arthurmao.me/2016/01/python-argparse</guid>
			</item>
		
	</channel>
</rss>
