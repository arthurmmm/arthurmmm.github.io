<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>ArthurMao's Blog</title>
		<description>你好喵 ・ω・~☆</description>
		<link>http://www.arthurmao.me</link>
		<atom:link href="http://www.arthurmao.me/feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>使用pdb来debug python程序</title>
				<description>&lt;p&gt;Python的命令行debug程序pdb笔记&lt;/p&gt;

&lt;h2 id=&quot;pdbpython&quot;&gt;使用PDB打开python脚本&lt;/h2&gt;

&lt;p&gt;```python
‘’’
方法1：使用python -m pdb &lt;your script=&quot;&quot;&gt;
相当于在第一行程序之前设置一个断点
&#39;&#39;&#39;
$ python -m pdb test.py
&amp;gt; /root/test.py(3)&lt;module&gt;()
-&amp;gt; import sys,os&lt;/module&gt;&lt;/your&gt;&lt;/p&gt;

&lt;p&gt;’’’
方法2：在程序代码中添加pdb断点
比方法1方便，但是会更改源程序，调试完得全部删除
‘’’
import pdb&lt;/p&gt;

&lt;p&gt;print(‘hello’)
pdb.set_trace()
print(‘world’)
```&lt;/p&gt;

&lt;h2 id=&quot;pdb&quot;&gt;pdb常用命令&lt;/h2&gt;

&lt;p&gt;```
h =&amp;gt; 显示帮助，h后面可以跟上具体的指令来显示该指令的文档
l =&amp;gt; 浏览代码，默认是从第一行开始的11行，连续使用可以翻页。可以添加参数l(ist) [first [,last]]，比如l 0能回到行首。
b =&amp;gt; 设置断点，后面跟行号，会回显断点号
cl =&amp;gt; 清除断点，后面跟断点号可以清除指定的断点
disable =&amp;gt; 禁用断点，用法如cl，用enable解禁
n =&amp;gt; 下一行。不进入函数体
s =&amp;gt; 下一行，进入函数体
c =&amp;gt; 执行程序直到断点
p =&amp;gt; 后跟变量，打印变量值&lt;/p&gt;

&lt;p&gt;TIPS：在pdb中直接回车一般会执行上一条指令，可以更方便的用n/s跟踪程序或者用l翻页查看
```&lt;/p&gt;
</description>
				<pubDate>Sat, 05 Mar 2016 22:29:00 +0800</pubDate>
				<link>http://www.arthurmao.me/2016/03/python-pdb-debug</link>
				<guid isPermaLink="true">http://www.arthurmao.me/2016/03/python-pdb-debug</guid>
			</item>
		
			<item>
				<title>Linux下实现彩色/动态的命令行输出</title>
				<description>&lt;p&gt;如何在命令行脚本中打印彩色字体或者实现一个类似进度条的动态效果呢？&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;彩色输出&lt;/h2&gt;

&lt;p&gt;SHELL本身可以通过ANSI控制码来控制输出字体的格式，具体格式如下：    &lt;/p&gt;

&lt;p&gt;&lt;code&gt;bash
\033[&amp;lt;字体格式&amp;gt;;&amp;lt;前景色&amp;gt;;&amp;lt;背景色&amp;gt;m&amp;lt;输出&amp;gt;\033[0m
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在shell脚本中直接echo或者在python中按照上述格式print，就能显示对应的效果。 &lt;br /&gt;
基于这个原理我写了一个简单的python函数，在需要彩色输出的时候给出对应的参数就可以了：   &lt;/p&gt;

&lt;p&gt;&lt;code&gt;python
def _print(msg, fcolor=&#39;white&#39;, bcolor=&#39;black&#39;, mode=&#39;normal&#39;, end=None):
    fcolor_map = {
        &#39;black&#39;: 30,
        &#39;red&#39;: 31,
        &#39;green&#39;: 32,
        &#39;yellow&#39;: 33,
        &#39;blue&#39;: 34,
        &#39;purple&#39;: 35,
        &#39;cyan&#39;: 36,
        &#39;white&#39;: 37,
    }
    bcolor_map = {
        &#39;black&#39;: 40,
        &#39;red&#39;: 41,
        &#39;green&#39;: 42,
        &#39;yellow&#39;: 43,
        &#39;blue&#39;: 44,
        &#39;purple&#39;: 45,
        &#39;cyan&#39;: 46,
        &#39;white&#39;: 47,
    }
    mode_map = {
        &#39;normal&#39;: 0,
        &#39;bold&#39;: 1,
        &#39;underline&#39;: 4,
        &#39;blink&#39;: 5,
        &#39;invert&#39;: 7,
        &#39;hide&#39;: 8,
    }
    msg = &#39;\033[%(mode)s;%(fcolor)s;%(bcolor)sm%(msg)s\033[0m&#39; % {
        &#39;mode&#39;: mode,
        &#39;fcolor&#39;: fcolor,
        &#39;bcolor&#39;: bcolor,
        &#39;msg&#39;: msg,
    }
    if (not end):
        print(msg)
    else:
        print(msg,end=end)
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;动态输出&lt;/h2&gt;

&lt;p&gt;在我上面的代码中用到了print函数中的end选项，这个是python3.x中print函数非常实用的一个选项，简单来讲就是替换掉print的结束符–在默认情况下实用print都会在结尾自动跟一个换行符。   &lt;/p&gt;

&lt;p&gt;所以如果你不希望print换行，就可以&lt;code&gt;print(msg,end=&#39;&#39;)&lt;/code&gt;，而为了实现动态输出，我们需要在print完之后将光标移到行首，对应的转移字符就是&lt;code&gt;\r&lt;/code&gt;，因此使用&lt;code&gt;print(msg,end=&#39;\r&#39;)&lt;/code&gt;就可以让光标在每次print完后回到行首了。  &lt;br /&gt;
另外在print完后记得使用&lt;code&gt;sys.stdout.flush()&lt;/code&gt;来及时显示信息。      &lt;/p&gt;

&lt;p&gt;一些TIPS：   &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在python2中可以通过&lt;code&gt;from __future__ import print_function&lt;/code&gt;来使用python3的print功能。&lt;/li&gt;
  &lt;li&gt;在动态刷新当前行的时候，如果前一行的字符串比较长，多出来的部分不会被清掉，记得在结尾补上空白符来清除。&lt;/li&gt;
&lt;/ul&gt;
</description>
				<pubDate>Sat, 20 Feb 2016 17:53:00 +0800</pubDate>
				<link>http://www.arthurmao.me/2016/02/art-of-print</link>
				<guid isPermaLink="true">http://www.arthurmao.me/2016/02/art-of-print</guid>
			</item>
		
			<item>
				<title>实用的Linux/Shell命令之：awk sed</title>
				<description>&lt;p&gt;awk和sed是Linux下非常实用的文本处理工具，简单记录一下常见用法&lt;/p&gt;

&lt;h2 id=&quot;awksed&quot;&gt;awk和sed的区别&lt;/h2&gt;

&lt;p&gt;通常来讲，awk用来处理同一行中的数据，sed用来处理不同行之间的数据，一个横向一个纵向。&lt;/p&gt;

&lt;h2 id=&quot;awksed-1&quot;&gt;awk和sed的常用参数&lt;/h2&gt;

&lt;p&gt;网上有很多文档这里就不再多写了，比如可以参考：   &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;sed: http://www.iteye.com/topic/587673&lt;/li&gt;
  &lt;li&gt;awk: http://www.cnblogs.com/ggjucheng/archive/2013/01/13/2858470.html&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;常见用法&lt;/h2&gt;

&lt;p&gt;我在做Support时候经常遇到一种情况，需要查看不同端口报错数的分布，例如如下日志：   &lt;/p&gt;

&lt;p&gt;&lt;code&gt;bash
# test.log
2015-01-01 A1-FC00 GOOD
2015-01-04 B1-FC00 ERROR
2015-01-05 B1-FC00 GOOD
2015-01-05 A1-FC00 ERROR
2015-01-11 A1-FC00 ERROR
2015-01-22 A1-FC00 GOOD
2015-02-01 C1-FC00 ERROR
2015-02-01 B1-FC00 ERROR
2015-02-02 A1-FC00 ERROR
2015-02-05 C1-FC00 GOOD
2015-02-06 A1-FC00 ERROR
2015-02-11 A1-FC00 ERROR
2015-02-11 C1-FC00 GOOD
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;那么如何快速统计出各个端口的报错情况呢？这样：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bash
$ grep ERROR test.log | awk &#39;{print $2}&#39; | sort | uniq -c | sort -rn
      5 A1-FC00
      2 B1-FC00
      1 C1-FC00
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;统计时间分布也是类似的：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bash
$ grep ERROR test.log | awk &#39;{print $1}&#39; | sort | uniq -c | sort -rn
      2 2015-02-01
      1 2015-02-11
      1 2015-02-06
      1 2015-02-02
      1 2015-01-11
      1 2015-01-05
      1 2015-01-04
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果我们希望统计1月和2月的报错总数：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bash
$ grep ERROR test.log | awk &#39;{print $1}&#39; | awk -F &#39;-&#39; &#39;{print $1&quot;-&quot;$2}&#39; | sort | uniq -c | sort -rn
      5 2015-02
      3 2015-01
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果我们希望统计1月5号到2月5号之间的数据就需要使用sed了&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bash
$ sed -n &#39;/2015-01-05/,/2015-02-05/p&#39; test.log | grep ERROR | awk &#39;{print $1}&#39; | sort | uniq -c | sort -rn
      2 2015-02-01
      1 2015-02-02
      1 2015-01-11
      1 2015-01-05
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;但其实这样做比较麻烦，而且如果日志中没有2月5号的数据就会出问题，实际情况中由于日志都是按时间戳顺序记录的，因此可以人工查看日志文件，找到对应的行号，比如第一个1月5号的记录在日志第三行，最后一个2月5号的记录在日志第十行，那么我们就可以用sed把3~10行的数据抓出来，免去匹配时间戳的麻烦。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bash
$ sed -n &#39;3,10p&#39; test.log | grep ERROR | awk &#39;{print $1}&#39; | sort | uniq -c | sort -rn
      2 2015-02-01
      1 2015-02-02
      1 2015-01-11
      1 2015-01-05
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使用sed进行批量替换，比如我们想把端口A1-FC00替换成67，B1-FC00替换成68，C1-FC00替换成69：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bash
$ grep ERROR test.log | awk &#39;{print $2}&#39; | sort | uniq -c | sort -rn | sed &#39;s/A1-FC00/67/g&#39; | sed &#39;s/B1-FC00/68/g&#39; | sed &#39;s/C1-FC00/69/g&#39;
      5 67
      2 68
      1 69
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;另外在我另一篇博文&lt;a href=&quot;http://www.arthurmao.me/2015/10/replace-zypper-repo&quot;&gt;OpenSUSE配置国内源&lt;/a&gt; 中就使用了sed，配合find和xargs完成了对配置文件的批量替换更改：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;bash
$ find . -name &quot;repo*&quot; | sed &#39;s/.\///g&#39; | xargs -i sh -c &quot;cat {} | sed &#39;s/download.opensuse.org/mirrors.zju.edu.cn\/opensuse/g&#39; | sed &#39;s/repo-/zju\/repo-/g&#39; | sed &#39;s/openSUSE-13.2/zju\/openSUSE-13.2/g&#39; &amp;gt; zju-{}&quot;
&lt;/code&gt;&lt;/p&gt;

</description>
				<pubDate>Sat, 13 Feb 2016 11:01:00 +0800</pubDate>
				<link>http://www.arthurmao.me/2016/02/awk-sed</link>
				<guid isPermaLink="true">http://www.arthurmao.me/2016/02/awk-sed</guid>
			</item>
		
			<item>
				<title>Python的闭包和装饰器</title>
				<description>&lt;p&gt;Python的闭包和装饰器笔记&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;什么是闭包/装饰器？&lt;/h2&gt;

&lt;p&gt;用我自己的理解来讲：   &lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;闭包：一个函数，它的作用是通过输入参数构造另一个函数&lt;/li&gt;
  &lt;li&gt;装饰器：输入参数是一个函数的闭包，可以用语法糖@xxx来使用   &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;举点栗子&lt;/p&gt;

&lt;p&gt;```python
‘’’
闭包例子。实现了一个简单的html标签函数
‘’’
def func_maker(tag):
    def _func(msg):
        return ‘&amp;lt;%(tag)s&amp;gt;msg&amp;lt;/%(tag)s&amp;gt;’ % {‘tag’: tag}
    return _func&lt;/p&gt;

&lt;p&gt;html_maker = func_maker(‘html’)
div_maker = func_maker(‘div’)&lt;/p&gt;

&lt;p&gt;print html_maker(div_maker(‘Div Content’))&lt;/p&gt;

&lt;p&gt;’’’
装饰器例子。实现了一个简单的函数运行时间统计
‘’’
import sys, os
import time
from datetime import datetime, timedelta
def runtime(fmt):
    def _runtime(func):
        def _func(&lt;em&gt;args, **kwargs):
            start_ts = datetime.now()
            func(&lt;/em&gt;args, **kwargs)
            end_ts = datetime.now()
            delta = end_ts - start_ts
            print ‘start time: %s’ % datetime.strftime(start_ts, fmt)
            print ‘runtime: %s’ % delta
        return _func
    return _runtime&lt;/p&gt;

&lt;p&gt;@runtime(‘%Y-%m-%d %H:%M:%S’)
def testfunc1(sec):
    time.sleep(sec)&lt;/p&gt;

&lt;p&gt;@runtime(‘%H:%M:%S’)
def testfunc2(sec):
    time.sleep(sec)&lt;/p&gt;

&lt;p&gt;testfunc1(3)
testfunc2(5)
```&lt;/p&gt;
</description>
				<pubDate>Sat, 06 Feb 2016 21:33:00 +0800</pubDate>
				<link>http://www.arthurmao.me/2016/02/closure-and-decorator</link>
				<guid isPermaLink="true">http://www.arthurmao.me/2016/02/closure-and-decorator</guid>
			</item>
		
			<item>
				<title>Python的多线程与多进程</title>
				<description>&lt;p&gt;Python的多线程与多进程笔记&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;多线程与多进程的区别和适用场景&lt;/h2&gt;

&lt;p&gt;一般来讲多线程比多进程更轻量，消耗资源更少，因为线程之间是共享内存的而进程都拥有自己独立的内存。 &lt;br /&gt;
但是Python(CPython)在多线程的实现方面受限与GIL，在执行CPU密集型程序时并不能体现出优势，所以对于这类程序通常使用多进程实现。
另外python的threading模块并没有实现kill/terminate之类的强制退出方法，自己实现的话比较ugly，所以对于那些无法通过设置标志位退出的程序还是用multiprocess比较方便。  &lt;/p&gt;

&lt;h2 id=&quot;pythonthreading&quot;&gt;python的多线程模块threading&lt;/h2&gt;

&lt;p&gt;官方文档：https://docs.python.org/2.7/library/threading.html &lt;br /&gt;
一个简单的示例程序：&lt;/p&gt;

&lt;p&gt;```python
import sys, os
import time
from datetime import datetime, timedelta
import threading
‘’’
Queue.Queue是一个线程安全队列，非常适合用于线程间数据传递以及生产者消费者模型
‘’’
from Queue import Queue&lt;/p&gt;

&lt;p&gt;def threadTask(qin, qout):
    ‘’’
    threading.current_thread =&amp;gt; 获取当前线程的实例
    ‘’’
    cur_thd = threading.current_thread()
    while qin.qsize() &amp;gt; 0:
        inputs = qin.get()
        print(‘Thread %s is running…’ % cur_thd.ident)
        print(‘Accept input: %s’ % inputs)
        print(‘Sleeping %s seconds’ % inputs)
        time.sleep(inputs)
        qout.put(inputs+1)
    print(‘Thread %s is exiting…’ % cur_thd.ident)&lt;/p&gt;

&lt;p&gt;def main():
    inputs = [2,3,4,60,70]
    qin = Queue()
    for i in inputs:
        qin.put(i)
    qout = Queue()
    thd_list = []
    for i in range(3):
        thd = threading.Thread(target=threadTask, kwargs = {
            ‘qin’: qin,
            ‘qout’: qout,
        })
        ‘’’
        设置为守护线程：当主线程结束时自动终止这些线程
        如果没有设置daemon=True，当timeout发生后由于子线程仍未退出，主线程会继续等待
        ‘’’
        thd.daemon = True
        thd.start()
        thd_list.append(thd)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for thd in thd_list:
    &#39;&#39;&#39;
    join =&amp;gt; 主线程阻塞在此处等待子线程结束，可设置timeout。
    timeout发生后主线程取消阻塞，但子线程依然在后台执行
    &#39;&#39;&#39;
    thd.join(5)
    &#39;&#39;&#39;
    threading.is_alive可以用来判断子线程是超时退出还是超时退出
    &#39;&#39;&#39;
    if (thd.is_alive()):
        print(&#39;Thread %s is timeout!!&#39; % thd.ident)

&#39;&#39;&#39;
从qout中获取输出
&#39;&#39;&#39;
while qout.qsize():
    out = qout.get()
    print(&#39;=&amp;gt; %s&#39; % out)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;if &lt;strong&gt;name&lt;/strong&gt; == ‘&lt;strong&gt;main&lt;/strong&gt;’:
    main()
```&lt;/p&gt;

&lt;p&gt;另一种实现方法–继承threading.Thread类并重写run函数&lt;/p&gt;

&lt;p&gt;```python
class MyThread(threading.Thread):
    qin = None
    qout = None
    def &lt;strong&gt;init&lt;/strong&gt;(self, qin, qout):
        self.qin = qin
        self.qout = qout
        threading.Thread.&lt;strong&gt;init&lt;/strong&gt;(self)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def run(self):
    while self.qin.qsize() &amp;gt; 0:
        inputs = self.qin.get()
        print(&#39;Thread %s is running...&#39; % self.ident)
        print(&#39;Accept input: %s&#39; % inputs)
        print(&#39;Sleeping %s seconds&#39; % inputs)
        time.sleep(inputs)
        self.qout.put(inputs+1)
    print(&#39;Thread %s is exiting...&#39; % self.ident)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;def main():
    inputs = [3,4,50,60,70]
    qin = Queue()
    for i in inputs:
        qin.put(i)
    qout = Queue()
    thd_list = []
    for i in range(3):
        thd = MyThread(qin, qout)
        thd.daemon = True
        thd.start()
        thd_list.append(thd)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for thd in thd_list:
    thd.join(5)
    if (thd.isAlive()):
        print(&#39;Thread %s is timeout!!&#39; % thd.ident)

while qout.qsize():
    out = qout.get()
    print(&#39;=&amp;gt; %s&#39; % out)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;if &lt;strong&gt;name&lt;/strong&gt; == ‘&lt;strong&gt;main&lt;/strong&gt;’:
    main()
```&lt;/p&gt;

&lt;h2 id=&quot;pythonmultiprocessing&quot;&gt;python的多进程模块multiprocessing&lt;/h2&gt;

&lt;p&gt;Python的multiprocessing模块可以用类似多线程的方法实现多进程
官方文档：https://docs.python.org/2.7/library/multiprocessing.html&lt;/p&gt;

&lt;p&gt;```python
import sys, os
import time
from datetime import datetime, timedelta
import threading
import multiprocessing
‘’’
用multiprocessing.Queue替换Queue.Queue
‘’’
# from Queue import Queue
from multiprocessing import Queue&lt;/p&gt;

&lt;p&gt;def processTask(qin, qout):
    while qin.qsize() &amp;gt; 0:
        ‘’’
        os.getpid()直接可以获取当前进程的进程号
        ‘’’
        print(‘Process %s is running…’ % os.getpid())
        inputs = qin.get()
        print(‘Accept input: %s’ % inputs)
        print(‘Sleeping %s seconds’ % inputs)
        time.sleep(inputs)
        qout.put(inputs+1)
    print(‘Process %s is exiting…’ % os.getpid())&lt;/p&gt;

&lt;p&gt;def main():
    inputs = [2,3,4,60,70]
    qin = Queue()
    for i in inputs:
        qin.put(i)
    qout = Queue()
    proc_list = []
    for i in range(3):
        proc = multiprocessing.Process(target=processTask, kwargs={
            ‘qin’: qin,
            ‘qout’: qout,
        })
        proc.deamon = True
        proc.start()
        ‘’’
        用proc.pid获取子进程进程号
        ‘’’
        print(‘Start process %s’ % proc.pid)
        proc_list.append(proc)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for proc in proc_list:
    proc.join(5)
    if (proc.is_alive()):
        print(&#39;Process %s is timeout!!&#39; % proc.pid)
        &#39;&#39;&#39;
        子进程是可以强制终止的，这点比线程好
        &#39;&#39;&#39;
        proc.terminate()

while qout.qsize():
    out = qout.get()
    print(&#39;=&amp;gt; %s&#39; % out)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;if &lt;strong&gt;name&lt;/strong&gt; == ‘&lt;strong&gt;main&lt;/strong&gt;’:
    main()
```&lt;/p&gt;

&lt;h2 id=&quot;lock&quot;&gt;Lock机制&lt;/h2&gt;

&lt;p&gt;threading和multiprocessing还提供了各种的Lock机制，但在实际编程中大部分同步问题用Queue就能解决了，这里就简单记录一下。&lt;/p&gt;

&lt;p&gt;```python
‘’’
基本锁
‘’’
threading.Lock/multiprocess.Lock &lt;/p&gt;

&lt;p&gt;’’’
RLock，和Lock的区别在于允许同一线程内多次require而不会死锁
多次require RLock也需要多次release，直到所有的锁被释放
‘’’
threading.RLock/multiprocess.RLock&lt;/p&gt;

&lt;p&gt;’’’
Condition，比较高级的锁，支持notify，wait等较复杂的同步
‘’’
threading.Condition/multiprocess.Condition
```&lt;/p&gt;
</description>
				<pubDate>Sat, 23 Jan 2016 17:06:00 +0800</pubDate>
				<link>http://www.arthurmao.me/2016/01/multithread-and-multiprocess</link>
				<guid isPermaLink="true">http://www.arthurmao.me/2016/01/multithread-and-multiprocess</guid>
			</item>
		
			<item>
				<title>Python subprocess模块</title>
				<description>&lt;p&gt;Python subprocess通常用来调用并获得shell指令的输出，这里记录一下用法.
官方文档：https://docs.python.org/2.7/library/subprocess.html&lt;/p&gt;

&lt;h2 id=&quot;subprocess-&quot;&gt;subprocess 模块的基本用法&lt;/h2&gt;

&lt;p&gt;```python
import subprocess&lt;/p&gt;

&lt;p&gt;cmd = ‘’’ echo “Your shell command” ‘’’
p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
res, err = p.communicate()&lt;/p&gt;

&lt;p&gt;’’’
设置shell=True会存在shell injection的安全隐患，出于安全性考虑可以这么用
‘’’
cmd = [‘echo’, ‘“Your shell command”’]
p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
res, err = p.communicate()
```&lt;/p&gt;

&lt;h2 id=&quot;subprocess&quot;&gt;使用subprocess动态获取输出&lt;/h2&gt;

&lt;p&gt;有时候我们需要实时跟踪一个指令的输出，比如监控一个长ping的结果：&lt;/p&gt;

&lt;p&gt;```python
import subprocess&lt;/p&gt;

&lt;p&gt;cmd = ‘’’ ping localhost -c 5 ‘’’
p = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
while True:
    out = p.stdout.readline()
    if (out == ‘’):
        break
    print ‘Am in subprocess =&amp;gt; %s’ % out
```&lt;/p&gt;

&lt;h2 id=&quot;python2-vs-python3&quot;&gt;Python2 VS Python3&lt;/h2&gt;

&lt;p&gt;Python3对subprocess模块有了一些很不错的改进，比如：  &lt;/p&gt;

&lt;p&gt;```python
‘’’
1. Python3 支持context manager：通过dir指令可以看出Python3的subprocess模块存在__enter__和__exit__函数
‘’’
# python2
Python 2.7.9 (default, Nov 14 2015, 17:52:58)
[GCC 4.8.3 20140911 (Red Hat 4.8.3-9)] on linux2
Type “help”, “copyright”, “credits” or “license” for more information.
»&amp;gt; import subprocess
»&amp;gt; dir(subprocess.Popen)
[‘&lt;strong&gt;class&lt;/strong&gt;’, ‘&lt;strong&gt;del&lt;/strong&gt;’, ‘&lt;strong&gt;delattr&lt;/strong&gt;’, ‘&lt;strong&gt;dict&lt;/strong&gt;’, ‘&lt;strong&gt;doc&lt;/strong&gt;’, ‘&lt;strong&gt;format&lt;/strong&gt;’, ‘&lt;strong&gt;getattribute&lt;/strong&gt;’, ‘&lt;strong&gt;hash&lt;/strong&gt;’, ‘&lt;strong&gt;init&lt;/strong&gt;’, ‘&lt;strong&gt;module&lt;/strong&gt;’, ‘&lt;strong&gt;new&lt;/strong&gt;’, ‘&lt;strong&gt;reduce&lt;/strong&gt;’, ‘&lt;strong&gt;reduce_ex&lt;/strong&gt;’, ‘&lt;strong&gt;repr&lt;/strong&gt;’, ‘&lt;strong&gt;setattr&lt;/strong&gt;’, ‘&lt;strong&gt;sizeof&lt;/strong&gt;’, ‘&lt;strong&gt;str&lt;/strong&gt;’, ‘&lt;strong&gt;subclasshook&lt;/strong&gt;’, ‘&lt;strong&gt;weakref&lt;/strong&gt;’, ‘_child_created’, ‘_close_fds’, ‘_communicate’, ‘_communicate_with_poll’, ‘_communicate_with_select’, ‘_execute_child’, ‘_get_handles’, ‘_handle_exitstatus’, ‘_internal_poll’, ‘_set_cloexec_flag’, ‘_translate_newlines’, ‘communicate’, ‘kill’, ‘pipe_cloexec’, ‘poll’, ‘send_signal’, ‘terminate’, ‘wait’]&lt;/p&gt;

&lt;h1 id=&quot;python3&quot;&gt;python3&lt;/h1&gt;
&lt;p&gt;Python 3.4.3 (default, Nov 14 2015, 18:34:36)
[GCC 4.8.3 20140911 (Red Hat 4.8.3-9)] on linux
Type “help”, “copyright”, “credits” or “license” for more information.
»&amp;gt; import subprocess
»&amp;gt; dir(subprocess.Popen)
[‘&lt;strong&gt;class&lt;/strong&gt;’, ‘&lt;strong&gt;del&lt;/strong&gt;’, ‘&lt;strong&gt;delattr&lt;/strong&gt;’, ‘&lt;strong&gt;dict&lt;/strong&gt;’, ‘&lt;strong&gt;dir&lt;/strong&gt;’, ‘&lt;strong&gt;doc&lt;/strong&gt;’, ‘&lt;strong&gt;enter&lt;/strong&gt;’, ‘&lt;strong&gt;eq&lt;/strong&gt;’, ‘&lt;strong&gt;exit&lt;/strong&gt;’, ‘&lt;strong&gt;format&lt;/strong&gt;’, ‘&lt;strong&gt;ge&lt;/strong&gt;’, ‘&lt;strong&gt;getattribute&lt;/strong&gt;’, ‘&lt;strong&gt;gt&lt;/strong&gt;’, ‘&lt;strong&gt;hash&lt;/strong&gt;’, ‘&lt;strong&gt;init&lt;/strong&gt;’, ‘&lt;strong&gt;le&lt;/strong&gt;’, ‘&lt;strong&gt;lt&lt;/strong&gt;’, ‘&lt;strong&gt;module&lt;/strong&gt;’, ‘&lt;strong&gt;ne&lt;/strong&gt;’, ‘&lt;strong&gt;new&lt;/strong&gt;’, ‘&lt;strong&gt;reduce&lt;/strong&gt;’, ‘&lt;strong&gt;reduce_ex&lt;/strong&gt;’, ‘&lt;strong&gt;repr&lt;/strong&gt;’, ‘&lt;strong&gt;setattr&lt;/strong&gt;’, ‘&lt;strong&gt;sizeof&lt;/strong&gt;’, ‘&lt;strong&gt;str&lt;/strong&gt;’, ‘&lt;strong&gt;subclasshook&lt;/strong&gt;’, ‘&lt;strong&gt;weakref&lt;/strong&gt;’, ‘_check_timeout’, ‘_child_created’, ‘_close_fds’, ‘_communicate’, ‘_execute_child’, ‘_get_devnull’, ‘_get_handles’, ‘_handle_exitstatus’, ‘_internal_poll’, ‘_remaining_time’, ‘_save_input’, ‘_translate_newlines’, ‘_try_wait’, ‘communicate’, ‘kill’, ‘poll’, ‘send_signal’, ‘terminate’, ‘wait’]&lt;/p&gt;

&lt;h1 id=&quot;python3popen&quot;&gt;因此在Python3中，正确打开一个Popen的姿势应该是这样的&lt;/h1&gt;
&lt;p&gt;with subprocess.Popen(cmd) as p:
    res,err = p.communicate()&lt;/p&gt;

&lt;p&gt;’’’
2. Python3 中的subprocess支持timeout选项，在执行可能会hung的指令时非常有用！
‘’’
cmd = ‘’’ sleep 10 ‘’’
with subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) as p:
    try:
         out,res = p.communicate(timeout=5)
     except subprocess.TimeoutExpired:
         p.kill()
         print(‘Command timeout!!’)&lt;/p&gt;

&lt;p&gt;’’’
3. Python3中subprocess的返回值是byte，如果要用作string的话需要做个转换
‘’’
cmd = ‘’’ echo “hello” ‘’’
with subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE) as p:
    try:
         out,res = p.communicate(timeout=5)
         out = out.decode()
         print(out)
     except subprocess.TimeoutExpired:
         p.kill()
         print(‘Command timeout!!’)&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;
</description>
				<pubDate>Sat, 16 Jan 2016 21:02:00 +0800</pubDate>
				<link>http://www.arthurmao.me/2016/01/python-subprocess</link>
				<guid isPermaLink="true">http://www.arthurmao.me/2016/01/python-subprocess</guid>
			</item>
		
			<item>
				<title>Python argparse模块</title>
				<description>&lt;p&gt;Python有很多命令行选项相关的模块，比如getopt, optparse等，各种都用过一下后感觉还是argparse最方便最轻量。  &lt;br /&gt;
官方详细文档：  https://docs.python.org/2.7/library/argparse.html&lt;/p&gt;

&lt;h2 id=&quot;argparse-&quot;&gt;argparse 模块的基本用法&lt;/h2&gt;

&lt;p&gt;```python
import logging&lt;/p&gt;

&lt;p&gt;’’’
第一步：创建parser实例
‘’’
parser = argparse.ArgumentParser(description=’Write overall help message here’)&lt;/p&gt;

&lt;p&gt;’’’
第二步：创建参数和选项
‘’’
parser.add_argument(‘myargs’, nargs=’+’, 
    help=’My arguments’)
parser.add_argument(‘-o’, ‘–myopts’, default=’hello’
    help=’My options’)
parser.add_argument(‘-f’, ‘–myflag’, action=’store_true’
    help=’My flag’)&lt;/p&gt;

&lt;p&gt;’’’
第三步：获取参数
‘’’
args = parser.parse_args()
myargs = args.myargs
myopts = args.myopts
myflag = args.myflag
```&lt;/p&gt;

&lt;h2 id=&quot;argparse--1&quot;&gt;argparse 实用选项&lt;/h2&gt;

&lt;p&gt;以下是一些常见的参数，通常已经能满足一般命令行工具的需求了。&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;p&gt;default：参数默认值。&lt;/p&gt;

&lt;p&gt;nargs: 参数个数，若有多个参数则用空格分隔
注意如果有配置nargs（哪怕nargs=1），那么拿到的参数是一个list，否则就是一个值&lt;/p&gt;

&lt;p&gt;action：执行操作，通常设置为store_true用于无需接受参数的选项比如–debug这种。&lt;/p&gt;

&lt;p&gt;type：输入值的类型，其实就是帮你做了一个显示类型转换，不指定的话默认是string&lt;/p&gt;

&lt;p&gt;choice：限制输入值的种类，例如choice=[‘choiceA’, ‘choiceB’]&lt;/p&gt;

&lt;p&gt;help：简单说明&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;
</description>
				<pubDate>Sun, 03 Jan 2016 11:09:00 +0800</pubDate>
				<link>http://www.arthurmao.me/2016/01/python-argparse</link>
				<guid isPermaLink="true">http://www.arthurmao.me/2016/01/python-argparse</guid>
			</item>
		
			<item>
				<title>使用Splunk生成Linux系统内存用量图</title>
				<description>&lt;p&gt;Linux的可用内存算法如下：&lt;br /&gt;
&lt;code&gt;available = free + cached + buffer&lt;/code&gt; &lt;br /&gt;
现在系统日志中分别记录了free, cached, buffer的数值和内存总量，日志格式大致如下：   &lt;/p&gt;

&lt;p&gt;```bash&lt;/p&gt;
&lt;timestamp&gt; hostname=&lt;host&gt; itemKey=memory.free value=&lt;value&gt;
&lt;timestamp&gt; hostname=&lt;host&gt; itemKey=memory.cached value=&lt;value&gt;
&lt;timestamp&gt; hostname=&lt;host&gt; itemKey=memory.buffers value=&lt;value&gt;
&lt;timestamp&gt; hostname=&lt;host&gt; itemKey=memory.total value=&lt;value&gt;
&lt;timestamp&gt; hostname=&lt;host&gt; itemKey=memory.free value=&lt;value&gt;
...

```

现在需要使用Splunk统计若干个host的内存用量并生成报表  
由于需要做计算的信息分布在不同行上，涉及到了Splunk的分组计算，最后的搜索语句如下：   

```bash
index=xxx
{
    hostname=host1 OR
    hostname=host2 OR
    ...
}
itemKey=memory.* |

# 第一步使用BUCKET进行强制分片，计算每分钟的平均值，避免timestamp不同步的问题
# 比如下面这个数据：
#     11:30 itemKey=memory.cached value = 1
#     11:30 itemKey=memory.free value = 1
#     11:31 itemKey=memory.buffers value = 1
#     11:31 itemKey=memory.total value = 5
# 如果不进行显式分片的话默认按照时间戳分片，就会把同一组的值分到两组中去，导致结果不正确。

BUCKET _time span=1m | 
STATS AVG(value) AS value BY _time hostname itemKey | 

# 由于stats不能做除法，这里需要把memory.total和其他值分开放在不同的field中，做法如下：
# - 使用IF语句区分value的含义并存到指定的field中，如果不是指定的类型就设为0
# - 使用STATS语句将相同的field求和，这样就能将不同行的数据处理到同一行中
# - 最后使用EVAL进行同行数据计算

EVAL memfree = IF(
    itemKey == &quot;memory.cached&quot; OR
    itemKey == &quot;memory.free&quot; OR
    itemKey == &quot;memory.buffers&quot;
    , value, 0
) | 
EVAL memtotal = IF(
    itemKey == &quot;memory.total&quot;
    , value, 0
) | 
STATS
    SUM(memfree) AS memfree
    SUM(memtotal) AS memtotal
BY hostname, _time | 
EVAL memuseage = (memtotal - memfree) / memtotal * 100 | 
TIMECHART minspan=1m AVG(memuseage) BY hostname
```
&lt;/value&gt;&lt;/host&gt;&lt;/timestamp&gt;&lt;/value&gt;&lt;/host&gt;&lt;/timestamp&gt;&lt;/value&gt;&lt;/host&gt;&lt;/timestamp&gt;&lt;/value&gt;&lt;/host&gt;&lt;/timestamp&gt;&lt;/value&gt;&lt;/host&gt;&lt;/timestamp&gt;
</description>
				<pubDate>Sat, 19 Dec 2015 15:20:00 +0800</pubDate>
				<link>http://www.arthurmao.me/2015/12/splunk-memory-usage</link>
				<guid isPermaLink="true">http://www.arthurmao.me/2015/12/splunk-memory-usage</guid>
			</item>
		
			<item>
				<title>Python logging模块</title>
				<description>&lt;p&gt;Python logging模块笔记&lt;/p&gt;

&lt;h2 id=&quot;logging-&quot;&gt;logging 模块的基本用法&lt;/h2&gt;

&lt;p&gt;```python
import logging&lt;/p&gt;

&lt;p&gt;’’’
level设定显示log的级别
datefmt是时间的显示方式
FORMAT是一个自定义的字符串，用于定义日志的格式。
‘’’
logging.basicConfig(level=logging.DEBUG,
    format = FORMAT,
    datefmt = ‘%Y-%m-%d %H:%M:%S’)&lt;/p&gt;

&lt;p&gt;’’’
默认情况下日志输出到屏幕，
需要写文件时得加上filename属性
‘’’
logging.basicConfig(format=FORMAT,
        filename=’test.log’
)&lt;/p&gt;

&lt;p&gt;’’’
需要打印信息的时候这样做
‘’’
logging.debug(‘a debug message’)
logging.info(‘a debug message’)
logging.warning(‘a debug message’)
logging.error(‘a debug message’)
logging.critical(‘a debug message’)&lt;/p&gt;

&lt;p&gt;’’’
也可以打印异常堆栈
‘’’
logging.exception(‘a debug message’)&lt;/p&gt;

&lt;p&gt;’’’
推荐的基本格式，显示时间、事件级别和日志信息
‘’’
FORMAT = ‘%(asctime)s %(levelname)s: %(message)s’&lt;/p&gt;

&lt;p&gt;’’’
额外显示了线程号，模块名和代码行号，调试的时候非常有用
‘’’
FORMAT = ‘%(thread)d %(asctime)s %(levelname)s %(module)s/%(lineno)d: %(message)s’&lt;/p&gt;

&lt;p&gt;’’’
还可以自定义一些额外的字段，例如下面的username，在打印时需要用extra指定一个dict用于解释自定义字段
‘’’
FORMAT=’%(thread)d %(asctime)s %(levelname)s %(module)s/%(lineno)d [%(username)s]: %(message)s’
d = {‘username’:’arthur’}
logger.warning(‘hihi’,extra=d)&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h2 id=&quot;log-rotation&quot;&gt;日志分卷归档(log rotation)&lt;/h2&gt;

&lt;p&gt;```python
import logging.handlers&lt;/p&gt;

&lt;p&gt;’’’
使用RotatingFileHandler按日志大小分卷
‘’’&lt;/p&gt;

&lt;p&gt;mylogger = logging.getLogger(‘mylogger’)
mylogger.setLevel(logging.DEBUG)
FORMAT = ‘%(asctime)s: %(message)s’
handler = logging.handlers.RotatingFileHandler(
    ‘mylog’, 
    maxBytes=1024*1024, # 1M per log
    backupCount=10, # 10 logs in total
)
# class logging.handlers.RotatingFileHandler(filename, mode=’a’, maxBytes=0, backupCount=0, encoding=None, delay=0)&lt;/p&gt;

&lt;p&gt;formatter = logging.Formatter(fmt=FORMAT)
# If you want to use GMT t/z
import time
formatter.converter = time.gmtime 
####
handler.setFormatter(formatter)
mylogger.addHandler(handler)
mylogger.info(‘Log a message here’)&lt;/p&gt;

&lt;p&gt;’’’
按照时间分卷只需将上面例子中的logging.handlers.RotatingFileHandler替换成logging.handlers.TimedRotatingFileHandler
‘’’
handler = logging.handlers.TimedRotatingFileHandler(
    ‘mylog’,
    when = ‘W0’,
    utc = True,
)
# class logging.handlers.TimedRotatingFileHandler(filename, when=’h’, interval=1, backupCount=0, encoding=None, delay=False, utc=False)&lt;/p&gt;

&lt;p&gt;```&lt;/p&gt;

&lt;h2 id=&quot;logging&quot;&gt;logging模块的一些参考表格&lt;/h2&gt;

&lt;h3 id=&quot;basicconfig&quot;&gt;basicConfig的属性&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Format&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;filename&lt;/td&gt;
      &lt;td&gt;Specifies that a FileHandler be created, using the specified filename, rather than a StreamHandler.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;filemode&lt;/td&gt;
      &lt;td&gt;Specifies the mode to open the file, if filename is specified (if filemode is unspecified, it defaults to ‘a’).&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;format&lt;/td&gt;
      &lt;td&gt;Use the specified format string for the handler.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;datefmt&lt;/td&gt;
      &lt;td&gt;Use the specified date/time format.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;level&lt;/td&gt;
      &lt;td&gt;Set the root logger level to the specified level.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;stream&lt;/td&gt;
      &lt;td&gt;Use the specified stream to initialize the StreamHandler. Note that this argument is incompatible with ‘filename’ - if both are present, ‘stream’ is ignored.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;format&quot;&gt;FORMAT中可以使用的参数&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Attribute&lt;/th&gt;
      &lt;th&gt;Format&lt;/th&gt;
      &lt;th&gt;Description&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;args&lt;/td&gt;
      &lt;td&gt;You shouldn’t need to format this yourself.&lt;/td&gt;
      &lt;td&gt;The tuple of arguments merged into msg to produce message, or a dict whose values are used for the merge (when there is only one argument, and it is a dictionary).&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;asctime&lt;/td&gt;
      &lt;td&gt;%(asctime)s&lt;/td&gt;
      &lt;td&gt;Human-readable time when the LogRecord was created. By default this is of the form ‘2003-07-08 16:49:45,896’ (the numbers after the comma are millisecond portion of the time).&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;created&lt;/td&gt;
      &lt;td&gt;%(created)f&lt;/td&gt;
      &lt;td&gt;Time when the LogRecord was created (as returned by time.time()).&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;exc_info&lt;/td&gt;
      &lt;td&gt;You shouldn’t need to format this yourself.&lt;/td&gt;
      &lt;td&gt;Exception tuple (à la sys.exc_info) or, if no exception has occurred, None.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;filename&lt;/td&gt;
      &lt;td&gt;%(filename)s&lt;/td&gt;
      &lt;td&gt;Filename portion of pathname.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;funcName&lt;/td&gt;
      &lt;td&gt;%(funcName)s&lt;/td&gt;
      &lt;td&gt;Name of function containing the logging call.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;levelname&lt;/td&gt;
      &lt;td&gt;%(levelname)s&lt;/td&gt;
      &lt;td&gt;Text logging level for the message (‘DEBUG’, ‘INFO’, ‘WARNING’, ‘ERROR’, ‘CRITICAL’).&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;levelno&lt;/td&gt;
      &lt;td&gt;%(levelno)s&lt;/td&gt;
      &lt;td&gt;Numeric logging level for the message (DEBUG, INFO, WARNING, ERROR, CRITICAL).&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;lineno&lt;/td&gt;
      &lt;td&gt;%(lineno)d&lt;/td&gt;
      &lt;td&gt;Source line number where the logging call was issued (if available).&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;module&lt;/td&gt;
      &lt;td&gt;%(module)s&lt;/td&gt;
      &lt;td&gt;Module (name portion of filename).&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;msecs&lt;/td&gt;
      &lt;td&gt;%(msecs)d&lt;/td&gt;
      &lt;td&gt;Millisecond portion of the time when the LogRecord was created.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;message&lt;/td&gt;
      &lt;td&gt;%(message)s&lt;/td&gt;
      &lt;td&gt;The logged message, computed as msg % args. This is set when Formatter.format() is invoked.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;msg&lt;/td&gt;
      &lt;td&gt;You shouldn’t need to format this yourself.&lt;/td&gt;
      &lt;td&gt;The format string passed in the original logging call. Merged with args to produce message, or an arbitrary object (see Using arbitrary objects as messages).&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;name&lt;/td&gt;
      &lt;td&gt;%(name)s&lt;/td&gt;
      &lt;td&gt;Name of the logger used to log the call.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;pathname&lt;/td&gt;
      &lt;td&gt;%(pathname)s&lt;/td&gt;
      &lt;td&gt;Full pathname of the source file where the logging call was issued (if available).&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;process&lt;/td&gt;
      &lt;td&gt;%(process)d&lt;/td&gt;
      &lt;td&gt;Process ID (if available).&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;processName&lt;/td&gt;
      &lt;td&gt;%(processName)s&lt;/td&gt;
      &lt;td&gt;Process name (if available).&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;relativeCreated&lt;/td&gt;
      &lt;td&gt;%(relativeCreated)d&lt;/td&gt;
      &lt;td&gt;Time in milliseconds when the LogRecord was created, relative to the time the logging module was loaded.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;thread&lt;/td&gt;
      &lt;td&gt;%(thread)d&lt;/td&gt;
      &lt;td&gt;Thread ID (if available).&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;threadName&lt;/td&gt;
      &lt;td&gt;%(threadName)s&lt;/td&gt;
      &lt;td&gt;Thread name (if available).&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</description>
				<pubDate>Sat, 05 Dec 2015 20:22:00 +0800</pubDate>
				<link>http://www.arthurmao.me/2015/12/python-logging</link>
				<guid isPermaLink="true">http://www.arthurmao.me/2015/12/python-logging</guid>
			</item>
		
			<item>
				<title>Python2/Python3 多版本安装和配置</title>
				<description>&lt;p&gt;Python2/Python3 多版本安装和配置&lt;/p&gt;

&lt;h2 id=&quot;python&quot;&gt;下载python包&lt;/h2&gt;

&lt;p&gt;网站：https://www.python.org/ftp/python/  &lt;/p&gt;

&lt;p&gt;&lt;code&gt;
$ wget https://www.python.org/ftp/python/3.4.3/Python-3.4.3.tgz   
$ wget https://www.python.org/ftp/python/2.7.9/Python-2.7.9.tgz  
&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;配置和安装&lt;/h2&gt;

&lt;p&gt;```
$ yum install sqlite-devel openssl openssl-devel&lt;/p&gt;

&lt;p&gt;$ tar xvzf Python-2.7.9.tgz  &lt;br /&gt;
$ ./configure –with-ensurepip=install
$ make&lt;br /&gt;
$ make install&lt;/p&gt;

&lt;p&gt;$ tar xvzf Python-3.4.3.tgz  &lt;br /&gt;
$ ./configure –with-ensurepip=install
$ make&lt;br /&gt;
$ make altinstall
```&lt;/p&gt;

&lt;p&gt;注意对于多个版本的python，主要版本使用&lt;code&gt;make install&lt;/code&gt;安装，其他版本使用&lt;code&gt;make altinstall&lt;/code&gt;安装！&lt;br /&gt;
在python 2.7或者3.4之后，使用–with-ensurepip=install可以自带pip，非常方便。&lt;/p&gt;
</description>
				<pubDate>Sat, 14 Nov 2015 23:00:00 +0800</pubDate>
				<link>http://www.arthurmao.me/2015/11/manual-install-python</link>
				<guid isPermaLink="true">http://www.arthurmao.me/2015/11/manual-install-python</guid>
			</item>
		
	</channel>
</rss>
